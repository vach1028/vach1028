<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[abcdef]]></title>
    <url>%2F2018%2F08%2F13%2Fabcdef%2F</url>
    <content type="text"><![CDATA[标题 描述 1概要]]></content>
      <categories>
        <category>abc</category>
      </categories>
      <tags>
        <tag>a|ab|abc，1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化部署需要注意事项]]></title>
    <url>%2F2017%2F11%2F16%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[0、jenkinsfile涉及步骤123456代码更新（从gogs拉取最新提交代码）构建代码（执行mvn clean compile命令）打包服务（执行mvn package， 对于多个jar包需要特别处理）创建镜像（构建docker镜像）推送镜像（发布镜像到DockerRegistry）部署环境（在指定环境拉取最新镜像并运行） 1、对于同一个DockerRegistry中，一个项目有两个部署环境如何构建 内网部署两套环境（开发环境及测试环境）且都使用自动化部署的情况下，需要注意推送镜像的镜像名要做区分。保证同一库里面的docker镜像不会被覆盖。 2、执行过程报错排查 本地构建代码正常但在构建环境上失败，请检查检查环境的maven库对应包版本是否一致、maven编译插件指定的jdk版本是否过低等，并确保该环境能访问到公司maven私服。 部署环境失败，目标服务机器是否能够正常访问到DockerRegistry并成功拉取镜像。 3、多个子模块如何构建 项目中有多个子模块时，根目录pom文件将各个模块关联，保证在根目录下执行mvn install能对各个模块完成打包，降低实现复杂度。 具体例子（IDEA下）：12345需要maven对两个子模块进行打包，并对两个jar进行docker镜像构建。主项目下面的pom文件， 使用modules关联两个子模块；在两个子模块下分别添加Dockerfile文件;指定‘打包服务’步骤后，从各个子模块target中复制jar至Dockerfile平级目录中；创建镜像步骤对，分别对两个jar创建镜像，并分别上传至DockerRegistry。 4、pom文件需要添加maven-compiler-plugin插件 指定maven编译期间源码的开发版本及编译版本，与构建环境保持一致。 5、添加spring-boot-starter-actuator依赖 pom文件添加添加spring-boot-starter-actuator依赖。spring-boot-starter-actuator_这个库让我们可以访问应用的很多信息，包括：/env、/info、/metrics、/health等。其中health接口可以查看应用的健康状态。可以进行扩展将磁盘检测和数据库检测结果显示。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo命令介绍]]></title>
    <url>%2F2017%2F08%2F06%2Fhexo%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[安装及初始化123npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 简写12345hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 服务器1234567hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件改动12hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 待补充]]></content>
  </entry>
  <entry>
    <title><![CDATA[一些带人的经验总结]]></title>
    <url>%2F2017%2F08%2F06%2F%E4%B8%80%E4%BA%9B%E5%B8%A6%E4%BA%BA%E7%9A%84%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些带人需要注意的事项，仅供参考！ 不要希望学的太快，迅速见效，学习是一个过程。 尽量用实例来驱动，动嘴巴讲没效果。 要督促，让他们每天汇报工作情况。 不要跑偏，IT技术很多，乱花渐欲迷人眼，知道什么该学，该什么时候学。 要有文档，计划，时间管理等概念。 世界是负责人的人创造的，不要试图逃避什么。 不要好高骛远，想着去IBM，Google工作，脚踏实地最重要！]]></content>
      <tags>
        <tag>-收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swagger-ui注解说明]]></title>
    <url>%2F2017%2F08%2F06%2Fswagger-ui%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[注解说明： @Api：用在类上，说明该类的作用 @ApiOperation：用在方法上，说明方法的作用 @ApiImplicitParams：用在方法上包含一组参数说明 @ApiImplicitParam：用在@ApiImplicitParams注解中，指定一个请求参数的各个方面 paramType：参数放在哪个地方 header--&gt;请求参数的获取：@RequestHeader query--&gt;请求参数的获取：@RequestParam path（用于restful接口）--&gt;请求参数的获取：@PathVariable body（不常用） form（不常用） name：参数名 dataType：参数类型 required：参数是否必须传 value：参数的意思 defaultValue：参数的默认值 @ApiResponses：用于表示一组响应 @ApiResponse：用在@ApiResponses中，一般用于表达一个错误的响应信息 code：数字，例如400 message：信息，例如&quot;请求参数没填好&quot; response：抛出异常的类 @ApiModel：描述一个Model的信息（这种一般用在post创建的时候，使用@RequestBody这样的场景，请求参数无法使用@ApiImplicitParam注解进行描述的时候） @ApiModelProperty：描述一个model的属性 以上这些就是最常用的几个注解了。 需要注意的是： ApiImplicitParam这个注解不只是注解，还会影响运行期的程序，例子如下： 如果ApiImplicitParam中的phone的paramType是query的话，是无法注入到rest路径中的，而且如果是path的话，是不需要配置ApiImplicitParam的，即使配置了，其中的value=”手机号”也不会在swagger-ui展示出来。 具体其他的注解，查看： https://github.com/swagger-api/swagger-core/wiki/Annotations#apimodel生成文档效果：果方法效果： 完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html，就能看到上文所展示的RESTful API的页面。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目常用规范参考]]></title>
    <url>%2F2017%2F08%2F06%2F%E9%A1%B9%E7%9B%AE%E5%B8%B8%E7%94%A8%E8%A7%84%E8%8C%83%E5%8F%82%E8%80%83%2F</url>
    <content type="text"><![CDATA[项目介绍相关链接 接口文档 https://github.com/alibaba/druid/ http://projects.spring.io/spring-boot/ https://github.com/mybatis/mybatis-3 http://www.redis.net.cn/tutorial/3501.html 组织结构1234567891011121314151617181920212223242526272829 |——meeting/java | |——bean | | |——vo --前端显示对象 | | |——entity --数据库表对象| | |——dto --数据传输对象| | |——API --接口对象 | |——common | | |——bean --公共类| | |——util --工具类 | | |——cache --缓存 | |——config --配置文件 | |——controller --控制器 | |——core --核心公用类 | |——exception --统一异常处理 | |——filter --过滤器 | |——intercepter --日志记录 | |——mapper --mapper接口 | |——service --业务逻辑接口与实现类 | | |——API 处理接口业务 | | |——impl 接口实现类| | |——ScheduledTask 定时任务 | |——meeting/resource| |——mapper --mybatis xml文件 | |——sql --数据库对应版本sql文件 | |——static （前端页面） | | |——css | | |——html| | |——img | | |——js 技术选型 springboot mysql mybatis 持久层框架 maven 项目构建工具 redis+spring cache 缓存框架 log4j 日志组件 druid 连接池监控组件 requirejs + jquery 前端框架 环境搭建开发环境 Jdk8 Mysql5.7 Redis Maven 部署环境 centos7 Redis Docker 开发工具 MySql Git IntelliJ IDEA Navicat for MySQL 开发指南部署方式 手动打jar包，ftp上传至服务器； 执行build脚本生成docker镜像并启动 12自动化构建部署实现前，需要按照上步骤来处理。运行脚本文末附录会做相关解释。 #####缓存机制 本项目采用spring cache与Redis进行整合, 可以使用spring cache缓存注解来缓存对象，同时用来缓存的内存的是使用redis的内存，不会消耗JVM的内存，提升了性能，也便于后期的扩展。 RedisConfig类配置相关配置，包括自动生成key值规则，缓存失效等等。 默认缓存时效为一天。 缓存key生成说明每个缓存的 key 生成策略默认使用的是参数名+参数值自动生成key策略是类名+方法名+参数值支持SpringEL表达式 缓存注解 @Cacheable 能够根据方法的请求参数对其结果进行缓存 @CachePut 能够根据方法的请求参数对其结果进行缓存，触发真实方法的调用 @CacheEvict 能够根据一定的条件对缓存进行清空 缓存建议针对于写操作频繁的场景，不推荐使用缓存 统一方法入口 所有返回json数据或处理结果的方法都需要调用统一的方法入口(ActionResponse)来执行,以确保返回格式统一,并将异常统一管理起来 被调用的方法体只需处理正常逻辑,不考虑加try/catch,省去繁琐的编码,方便开发,如有特殊逻辑可将异常抛出 使用实例: 12public ResultForWeb getAllMeetingEquipment() &#123; Func&lt;ResultForWeb&gt; func = () -&gt; meetingEquipmentService.getAllMeetingEquipment(); return ActionResponse(func); &#125; 实体验证规范 对应实体打上相应注解(@NotEmpty,@NotNull,@Rang等) 使用统一的方法入口验证实体(ActionResponseGetString),验证成功才执行方法体 使用实例: 12public ResultForWeb editMeetingManagement(@Valid MeetingManagement model, BindingResult bindingResult) &#123; Func&lt;ResultForWeb&gt; func = () -&gt; meetingManagementService.editMeetingManagement(model); return ActionResponseGetString(func, bindingResult.hasErrors()); &#125; 命名规范包命名 包命名采用全小写命名 通过唯一域名+组件来命名(通常为 com.banggood.*) 类命名 类命名采用Pascal命名法 大写字母开头，各个单词首字母大写 方法命名 方法命名采用Camel命名法 小写字母开头，各个单词首字母大写 方法名的第一个单词应是动词 属性的getter和setter方法尽量使用自动生成，或者使用lombok插件 变量命名 采用Camel命名法 小写字母开头，各个单词首字母大写 常量命名 采用全大写命名法 所有字母均大写 静态资源文件命名 采用全小写命名法 所有的字母均小写，单词之间以下划线’_’分隔 注释要求团队成员都应该形成良好的写注释的习惯，方便以后阅读，以及为了后期生成可读性良好的Java Doc 类注释在每个类前面必须加上类注释，注释模板如下： 123456/*** Created by 开发者名 on 时间.** 类描述信息*/ 属性注释在每个属性前面必须加上属性注释，注释模板如下：12/** 提示信息 */private String strMsg = null; 方法注释在每个方法前面必须加上方法注释，注释模板如下： 123456789/*** 类方法的详细使用说明** @param 参数1 参数1的使用说明* @return 返回结果的说明* @author 作者 日期(2017/06/03)* @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明**/ 方法内部注释在方法内部使用单行或者多行注释，该注释根据实际情况添加。如：12//背景颜色Color bgColor = Color.RED git协作规范分支的使用1234存在分支master、develop、个人分支；首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在develop分支上，也就是说，develop分支是不稳定的，到某个时候，比如1.0版本发布时，再把develop分支合并到master上，在master分支发布1.0版本；每个人都在dev分支上干活，每个人都有自己的分支，所负责的功能开发完成后往develop分支上合并就可以了。 参考下图 合并策略--no-ff：不使用fast-forward方式合并，保留分支的commit历史；--squash：使用squash方式合并，把多次分支commit历史压缩为一次。主要在master分支和develop分支使用 提交信息格式要求1&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;// 空一行&lt;body&gt; type12345* Feat：新功能（feature）* Fix：修补bug* Update：功能上改动* Refactor：重构（即不是新增功能，也不是修改bug的代码变动）* Merge：增加测试 subject123commit 目的的简短描述，不超过50个字符。* 以动词开头* 结尾不加句号（`.`） body12body部分是对本次 commit 的详细描述，可以分成多行。描述参照：其是什么及为什么这么做，不用怎么做。 框架规范约定各类放置约定 123456789101112131415161718service类，需要在叫名`service`的包下，接口类以`Service`结尾，实现类以`ServiceImpl`结尾，如`UserServiceImpl`controller类，需要在以`controller`结尾的包下，类名以Controller结尾，如`UserController.java`mapper.xml，需要resource路径下，并以`Mapper.xml`结尾，如`UserMapper.xml`mapper接口，需要在名叫`mapper`的包下，并以`Mapper`结尾，如`UserMapper.java`实体类，系统业务相关非公共在`bean`包下，公用类在`common`包下；类名：首字母大写驼峰规则；方法名：首字母小写驼峰规则；常量：全大写；变量：首字母小写驼峰规则，尽量非缩写配置文件放到`src/main/resources`目录下静态资源文件放到`/resources`目录下`RequestMapping`要指定method Service/Mapper方法命名约定 123456789101112获取单个对象的方法用get做前缀获取多个对象的方法用list做前缀获取统计值的方法用count做前缀插入的方法用save（推荐）或insert做前缀删除的方法用remove（推荐）或delete做前缀修改的方法用update做前缀]]></content>
  </entry>
  <entry>
    <title><![CDATA[git使用手册]]></title>
    <url>%2F2017%2F08%2F06%2Fgit%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[邮箱名字git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; git config -l（列出所有） 初始化仓库git init 添加文件到Git仓库，分两步： 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 提交更改、比对要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。可以使用gitk或者git gui来比对。 git log查看日志。 git add =》 git commit 版本回退git log git reset --hard “（log上面的每一个对应的版本号）” 即可恢复到对应版本 当不想进行回退： -.命令还在直接使用 git reset --hard 对应的版本id -.命令窗口已经关了：使用git reflog（该命令会记录你的每一次操作），获取到版本id进行回退。 撤销修改命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 用命令`git reset HEAD file`可以把暂存区的修改撤销掉（unstage），重新放回工作区 具体场景参考： 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 删除文件rm filename 两种情况： 需要删除=》则git rm filename =&gt;git commit -m &quot;delete&quot; 误删除=》git checkout -- filename 分支合并Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 注意第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 没有进行add 直接commit是不会保存到库里面的。 远程仓库-》删除先删后加 git remote rm origin git remote add origin git@github.com:Liutos/foobar.git 远程仓库-》创建在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 远程仓库-》添加远程库git remote add origin git@github.com:michaelliao/learngit.git 提交使用：git push origin master 远程仓库-》克隆git clone git@github.com:michaelliao/gitskills.git bug分支git stash 储藏当前的工作 到新的分支进行补给修复，修复完成提交切换到主分支进行合并。删除bug分区。 接下来是恢复：第一、git stash apply 。git stash drop。 第二，git stash pop。 多个remotegit commit -m &quot;Change repo.&quot; # 先把所有为保存的修改打包为一个commit git remote remove origin # 删掉原来git源 git remote add origin [YOUR NEW .GIT URL] # 将新源地址写入本地版本库配置文件 git push -u origin master # 提交所有代码 或者： git remote set-url origin 问题解决git clone https://android.googlesource.com/kernel/common.git Cloning into common... warning: remote HEAD refers to nonexistent ref, unable to checkout. 改用： git clone http://android.googlesource.com/kernel/common.git git branch -a git checkout remotes/origin/android-3.0 OK. 忽略文件不起作用git rm --cache 原因是文件已经被追踪. 删除远程分支git branch -a git push origin --delete &lt;branchName&gt; 删除tag这么用： git push origin --delete tag &lt;tagname&gt; 也可以这样： git branch -r -d origin/branch-name git push origin :branch-name 123456 *.a # 忽略所有 .a 结尾的文件 !lib.a # 但 lib.a 除外/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt tag使用12345git tag -a v1.0 -m &quot;注释&quot; 添加标签git tag -d v1.0 删除标签git push origin --tagsgit push origin v1.1git tag -l -n stash使用12345678910git stash save -a &quot;messeag&quot;网上很多很多资料都没有加 -a 这个option选项，我想他们的代码开发可能都是在原代码上进行修改吧。而对于在项目里加入了代码新文件的开发来说，-a选项才会将新加入的代码文件同时放入暂存区。git stash popgit stash listgit stash pop stash@&#123;id&#125;git stash apply stash@&#123;id&#125;git stash drop &lt;stash@&#123;id&#125;&gt;git stash clear]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
